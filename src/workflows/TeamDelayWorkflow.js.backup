// Team Delay Workflow - Handles teammate delay notification requests
const OpenAI = require('openai');
const googleCalendarService = require('../services/googleCalendarService');
const outboundCallService = require('../services/outboundCallService');
const outboundCallSession = require('../services/outboundCallSession');
const databaseConnection = require('../services/databaseConnection');
const { globalTimingLogger } = require('../utils/timingLogger');
const performanceLogger = require('../utils/performanceLogger');

const openai = new OpenAI();

// Main delay notification workflow
async function delayNotificationWorkflow(callerInfo, transcript, appointments, language = 'english', streamSid) {
  try {
    globalTimingLogger.startOperation('Delay Notification Workflow');
    
    // Step 1: Show current appointments to teammate (no greeting since already greeted)
    const appointmentsList = formatAppointmentsForTeammate(appointments);
    const response = `I can see you have the following appointments:\n\n${appointmentsList}\n\nWhich appointment would you like to delay?`;
    
    // Store the current state for continuation
    const workflowData = {
      step: 'select_appointment',
      appointments: appointments,
      callerInfo: callerInfo,
      language: language,
      streamSid: streamSid,
      shouldEndCall: false
    };
    
    globalTimingLogger.endOperation('Delay Notification Workflow');
    
    return {
      response: response,
      workflowData: workflowData
    };
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Delay Notification Workflow');
    return {
      response: "I'm sorry, I'm having trouble accessing your appointments right now. Please try again later.",
      workflowData: { shouldEndCall: true }
    };
  }
}

// Continue the delay workflow based on user input
async function continueDelayWorkflow(streamSid, transcript, sessionData) {
  try {
    globalTimingLogger.startOperation('Continue Delay Workflow');
    
    // Add safety check for sessionData
    if (!sessionData || typeof sessionData !== 'object') {
      console.error('‚ùå Invalid sessionData:', sessionData);
      return {
        response: "I'm sorry, I'm having trouble with the session. Let me start over. Which appointment would you like to delay?",
        workflowData: { shouldEndCall: false }
      };
    }
    
    const { step, appointments, callerInfo, language } = sessionData;
    
    let result;
    if (step === 'select_appointment') {
      result = await handleAppointmentSelection(transcript, appointments, callerInfo, language, streamSid);
    } else if (step === 'get_new_time') {
      result = await handleNewTimeInput(transcript, sessionData, streamSid);
    } else if (step === 'confirm_time') {
      result = await handleTimeConfirmation(transcript, sessionData, streamSid);
    } else if (step === 'confirm_with_customer') {
      result = await handleCustomerConfirmation(transcript, sessionData, streamSid);
    } else if (step === 'waiting_for_customer') {
      result = await handleWaitingForCustomer(transcript, sessionData, streamSid);
    } else if (step === 'ask_more_help') {
      result = await handleMoreHelpRequest(transcript, sessionData, streamSid);
    } else {
      result = {
        response: "I'm not sure what you'd like to do. Could you please tell me which appointment you'd like to delay?",
        workflowData: { shouldEndCall: false }
      };
    }
    
    // Update session with new workflow data
    if (result.workflowData) {
      const sessionManager = require('../services/sessionManager');
      const session = sessionManager.getSession(streamSid);
      if (session && session.langChainSession) {
        // Merge the new workflow data with existing session data
        session.langChainSession.workflowData = {
          ...session.langChainSession.workflowData,
          ...result.workflowData
        };
        sessionManager.setLangChainSession(streamSid, session.langChainSession);
        console.log('üîÑ Updated workflow data:', session.langChainSession.workflowData);
      }
    }
    
    return result;
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Continue Delay Workflow');
    return {
      response: "I'm sorry, I'm having trouble processing your request. Please try again.",
      workflowData: { shouldEndCall: true }
    };
  }
}

// Handle appointment selection
async function handleAppointmentSelection(transcript, appointments, callerInfo, language, streamSid) {
  try {
    // Use OpenAI to determine which appointment the teammate wants to delay
    const systemPrompt = `You are helping a teammate select an appointment to delay. Based on their input, determine which appointment they want to delay.

Available appointments:
${appointments.map((apt, index) => `${index + 1}. ${apt.summary} - ${formatDateTime(apt.start.dateTime)}`).join('\n')}

The teammate might mention:
- Appointment names (like "head checkup", "eye checkup", "her checkup", "his checkup")
- Days (like "Sunday", "Monday") 
- Times (like "9 AM", "3 PM")
- Or just say the number
- Or say "appointment number X"

Examples:
- "head checkup" ‚Üí 1
- "her checkup" ‚Üí 1
- "his checkup" ‚Üí 1
- "Sunday appointment" ‚Üí 1  
- "eye checkup" ‚Üí 2
- "Monday appointment" ‚Üí 2
- "first one" ‚Üí 1
- "second one" ‚Üí 2
- "appointment number 1" ‚Üí 1
- "appointment 1" ‚Üí 1

Respond with ONLY the appointment number (1, 2, 3, etc.) or "none" if unclear.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Teammate says: "${transcript}"` }
      ],
      temperature: 0,
      max_tokens: 5
    });
    
    const selectedIndex = completion.choices[0].message.content.trim();
    console.log(`üîç Appointment selection result: "${selectedIndex}" for input: "${transcript}"`);
    
    const appointmentIndex = parseInt(selectedIndex) - 1;
    
    if (isNaN(appointmentIndex) || appointmentIndex < 0 || appointmentIndex >= appointments.length) {
      console.log(`‚ùå Invalid appointment index: ${appointmentIndex} (selectedIndex: "${selectedIndex}")`);
      return {
        response: "I'm not sure which appointment you'd like to delay. Could you please specify the appointment number or name?",
        workflowData: { 
          step: 'select_appointment',
          appointments: appointments,
          callerInfo: callerInfo,
          language: language,
          streamSid: streamSid,
          shouldEndCall: false 
        }
      };
    }
    
    console.log(`‚úÖ Selected appointment ${appointmentIndex + 1}: ${appointments[appointmentIndex].summary}`);
    
    const selectedAppointment = appointments[appointmentIndex];
    
    // Check if the transcript already contains new time information
    const timeKeywords = ['to', 'at', 'pm', 'am', 'later', 'tomorrow', 'next', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december', 'january'];
    const hasTimeInfo = timeKeywords.some(keyword => transcript.toLowerCase().includes(keyword));
    
    if (hasTimeInfo) {
      // User provided both appointment and time in one go - parse time first
      const timeResult = await parseTimeFromTranscript(transcript, selectedAppointment);
      
      if (timeResult.success) {
        // Ask for confirmation before updating calendar
        const response = `Perfect! I understand you want to delay "${selectedAppointment.summary}" to ${formatDateTime(timeResult.newTime.toISOString())}.\n\nIs this correct?`;
        
        const workflowData = {
          step: 'confirm_time',
          selectedAppointment: selectedAppointment,
          parsedTime: timeResult.newTime,
          appointments: appointments,
          callerInfo: callerInfo,
          language: language,
          streamSid: streamSid,
          shouldEndCall: false
        };
        
        return { response, workflowData };
      } else {
        // Time parsing failed, ask for clarification
        const response = `I can see you want to delay "${selectedAppointment.summary}", but I'm not sure about the new time. Could you please specify the date and time?`;
        
        const workflowData = {
          step: 'get_new_time',
          selectedAppointment: selectedAppointment,
          appointments: appointments,
          callerInfo: callerInfo,
          language: language,
          streamSid: streamSid,
          shouldEndCall: false
        };
        
        return { response, workflowData };
      }
    } else {
      // Ask for new time
      const response = `Great! I can see you want to delay "${selectedAppointment.summary}" which is currently scheduled for ${formatDateTime(selectedAppointment.start.dateTime)}.\n\nWhat would be the new time?`;
      
      const workflowData = {
        step: 'get_new_time',
        selectedAppointment: selectedAppointment,
        appointments: appointments,
        callerInfo: callerInfo,
        language: language,
        streamSid: streamSid,
        shouldEndCall: false
      };
      
      return { response, workflowData };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle Appointment Selection');
    return {
      response: "I'm having trouble understanding which appointment you want to delay. Please try again.",
      workflowData: { 
        step: 'select_appointment',
        appointments: appointments,
        callerInfo: callerInfo,
        language: language,
        streamSid: streamSid,
        shouldEndCall: false 
      }
    };
  }
}

// Parse time from transcript (helper function)
async function parseTimeFromTranscript(transcript, selectedAppointment) {
  try {
    // Use OpenAI to parse the new time
    const systemPrompt = `You are helping parse a new appointment time. The current appointment is:
- Title: ${selectedAppointment.summary}
- Current time: ${formatDateTime(selectedAppointment.start.dateTime)}
- Current timezone: ${selectedAppointment.start.timeZone || 'UTC'}

The teammate wants to reschedule to: "${transcript}"

Parse this into a specific date and time. Consider:
- "15 minutes later" means 15 minutes after the current time
- "tomorrow at 2 PM" means tomorrow at 2 PM
- "next Monday at 10 AM" means next Monday at 10 AM
- "from Sunday to Monday at September 29 at 12PM" means September 29 at 12:00 PM
- "shift to Monday at 12PM" means next Monday at 12:00 PM
- "February at 12PM" means February 25, 2025 at 12:00 PM (if current year is 2025)
- "25 September at 9PM" means September 25, 2025 at 9:00 PM
- Any specific date and time

Important: 
- If the user mentions a specific date like "September 29" or "Monday", use that date
- If they just say "Monday" without a date, assume it's the next Monday
- If they say "February" without a day, assume February 25, 2025
- If they say "25 September", use September 25, 2025
- Always use 2025 as the year unless specified otherwise

Respond with ONLY the new date and time in ISO format (YYYY-MM-DDTHH:mm:ss) or "unclear" if you can't parse it.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `New time: "${transcript}"` }
      ],
      temperature: 0,
      max_tokens: 30
    });
    
    const newTimeStr = completion.choices[0].message.content.trim();
    console.log(`üîç Time parsing result: "${newTimeStr}" for input: "${transcript}"`);
    
    if (newTimeStr === 'unclear') {
      console.log(`‚ùå Time parsing failed for input: "${transcript}"`);
      return { success: false, error: 'Time parsing failed' };
    }
    
    // Parse the new time
    const newDateTime = new Date(newTimeStr);
    console.log(`üîç Parsed date: ${newDateTime.toISOString()} (valid: ${!isNaN(newDateTime.getTime())})`);
    
    if (isNaN(newDateTime.getTime())) {
      console.log(`‚ùå Date parsing failed for: "${newTimeStr}"`);
      return { success: false, error: 'Date parsing failed' };
    }
    
    return { success: true, newTime: newDateTime };
    
  } catch (error) {
    console.error('‚ùå Error parsing time:', error);
    return { success: false, error: error.message };
  }
}

// Handle new time input
async function handleNewTimeInput(transcript, sessionData, streamSid) {
  try {
    const { selectedAppointment, callerInfo, language } = sessionData;
    
    // Use OpenAI to parse the new time
    const systemPrompt = `You are helping parse a new appointment time. The current appointment is:
- Title: ${selectedAppointment.summary}
- Current time: ${formatDateTime(selectedAppointment.start.dateTime)}
- Current timezone: ${selectedAppointment.start.timeZone || 'UTC'}

The teammate wants to reschedule to: "${transcript}"

Parse this into a specific date and time. Consider:
- "15 minutes later" means 15 minutes after the current time
- "tomorrow at 2 PM" means tomorrow at 2 PM
- "next Monday at 10 AM" means next Monday at 10 AM
- "from Sunday to Monday at September 29 at 12PM" means September 29 at 12:00 PM
- "shift to Monday at 12PM" means next Monday at 12:00 PM
- "February at 12PM" means February 25, 2025 at 12:00 PM (if current year is 2025)
- "25 September at 9PM" means September 25, 2025 at 9:00 PM
- Any specific date and time

Important: 
- If the user mentions a specific date like "September 29" or "Monday", use that date
- If they just say "Monday" without a date, assume it's the next Monday
- If they say "February" without a day, assume February 25, 2025
- If they say "25 September", use September 25, 2025
- Always use 2025 as the year unless specified otherwise

Respond with ONLY the new date and time in ISO format (YYYY-MM-DDTHH:mm:ss) or "unclear" if you can't parse it.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `New time: "${transcript}"` }
      ],
      temperature: 0,
      max_tokens: 30
    });
    
    const newTimeStr = completion.choices[0].message.content.trim();
    console.log(`üîç Time parsing result: "${newTimeStr}" for input: "${transcript}"`);
    
    if (newTimeStr === 'unclear') {
      console.log(`‚ùå Time parsing failed for input: "${transcript}"`);
      return {
        response: "I'm not sure about the new time you mentioned. Could you please be more specific?",
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
    // Parse the new time
    const newDateTime = new Date(newTimeStr);
    console.log(`üîç Parsed date: ${newDateTime.toISOString()} (valid: ${!isNaN(newDateTime.getTime())})`);
    
    if (isNaN(newDateTime.getTime())) {
      console.log(`‚ùå Date parsing failed for: "${newTimeStr}"`);
      return {
        response: "I'm having trouble understanding the new time. Could you please try again?",
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
    // Calculate duration
    const originalStart = new Date(selectedAppointment.start.dateTime);
    const originalEnd = new Date(selectedAppointment.end.dateTime);
    const duration = originalEnd.getTime() - originalStart.getTime();
    const newEndTime = new Date(newDateTime.getTime() + duration);
    
    // Update the appointment
    const updateData = {
      start: {
        dateTime: newDateTime.toISOString(),
        timeZone: selectedAppointment.start.timeZone || 'UTC'
      },
      end: {
        dateTime: newEndTime.toISOString(),
        timeZone: selectedAppointment.end.timeZone || 'UTC'
      }
    };
    
    try {
      await googleCalendarService.updateAppointment(selectedAppointment.id, updateData);
      
      // Log the delay to database
      await logDelayToDatabase({
        appointmentId: selectedAppointment.id,
        originalTime: selectedAppointment.start.dateTime,
        newTime: newDateTime.toISOString(),
        teammateInfo: callerInfo,
        reason: 'Teammate requested delay',
        status: 'updated'
      });
      
      // Make outbound call to customer
      const customerPhone = '+923450448426'; // Customer number to call
      const twilioPhoneNumber = '+4981424634017'; // Your Twilio phone number
      const customerMessage = `Hello! This is regarding your appointment "${selectedAppointment.summary}". We need to reschedule it to ${formatDateTime(newDateTime.toISOString())}. Is this new time okay with you?`;
      
      try {
        const callResult = await makeOutboundCallToCustomer(customerPhone, customerMessage, selectedAppointment, formatDateTime(newDateTime.toISOString()));
        
        if (callResult.success) {
          const response = `Perfect! I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI'm now calling the customer at ${customerPhone} to confirm the new time. Please wait for their response.`;
          
          const workflowData = {
            step: 'waiting_for_customer',
            selectedAppointment: selectedAppointment,
            newTime: newDateTime.toISOString(),
            customerPhone: customerPhone,
            callSid: callResult.callSid,
            callerInfo: callerInfo,
            language: language,
            streamSid: streamSid,
            shouldEndCall: false
          };
          
          return { response, workflowData };
        } else {
          // Fallback if call fails
          const response = `I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI tried to call the customer but couldn't reach them. You may want to contact them directly. Do you need any more help with delaying meetings?`;
          
          const workflowData = {
            step: 'ask_more_help',
            selectedAppointment: selectedAppointment,
            newTime: newDateTime.toISOString(),
            callerInfo: callerInfo,
            language: language,
            streamSid: streamSid,
            shouldEndCall: false
          };
          
          return { response, workflowData };
        }
      } catch (error) {
        console.error('‚ùå Failed to make outbound call:', error);
        
        // Fallback if call fails
        const response = `I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI tried to call the customer but couldn't reach them. You may want to contact them directly. Do you need any more help with delaying meetings?`;
        
        const workflowData = {
          step: 'ask_more_help',
          selectedAppointment: selectedAppointment,
          newTime: newDateTime.toISOString(),
          callerInfo: callerInfo,
          language: language,
          streamSid: streamSid,
          shouldEndCall: false
        };
        
        return { response, workflowData };
      }
      
    } catch (error) {
      globalTimingLogger.logError(error, 'Update Appointment');
      return {
        response: "I'm sorry, I couldn't update the appointment in the calendar. Please try again or contact support.",
        workflowData: { shouldEndCall: true }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle New Time Input');
    return {
      response: "I'm having trouble processing the new time. Please try again.",
      workflowData: { ...sessionData, shouldEndCall: false }
    };
  }
}

// Handle time confirmation from teammate
async function handleTimeConfirmation(transcript, sessionData, streamSid) {
  try {
    const { selectedAppointment, parsedTime, callerInfo, language } = sessionData;
    
    // Check if teammate confirms the time
    const confirmsTime = checkTimeConfirmation(transcript);
    
    if (confirmsTime === 'yes') {
      // Teammate confirmed - proceed with calendar update
      return await updateAppointmentWithTime(selectedAppointment, parsedTime, callerInfo, language, streamSid);
    } else if (confirmsTime === 'no') {
      // Teammate wants to change the time
      const response = `No problem! What would be the correct date and time for "${selectedAppointment.summary}"?`;
      
      const workflowData = {
        step: 'get_new_time',
        selectedAppointment: selectedAppointment,
        appointments: sessionData.appointments,
        callerInfo: callerInfo,
        language: language,
        streamSid: streamSid,
        shouldEndCall: false
      };
      
      return { response, workflowData };
    } else {
      // Unclear response
      const response = `I'm not sure if that's correct. Could you please say "yes" if the time is right, or "no" if you want to change it?`;
      
      return {
        response: response,
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle Time Confirmation');
    return {
      response: "I'm having trouble understanding your response. Please try again.",
      workflowData: { ...sessionData, shouldEndCall: false }
    };
  }
}

// Check if teammate confirms the time
function checkTimeConfirmation(transcript) {
  const lowerTranscript = transcript.toLowerCase();
  
  if (lowerTranscript.includes('yes') || lowerTranscript.includes('okay') || 
      lowerTranscript.includes('ok') || lowerTranscript.includes('sure') ||
      lowerTranscript.includes('correct') || lowerTranscript.includes('right') ||
      lowerTranscript.includes('good') || lowerTranscript.includes('fine') ||
      lowerTranscript.includes('confirmed') || lowerTranscript.includes('perfect')) {
    return 'yes';
  } else if (lowerTranscript.includes('no') || lowerTranscript.includes('not') ||
             lowerTranscript.includes('wrong') || lowerTranscript.includes('incorrect') ||
             lowerTranscript.includes('change') || lowerTranscript.includes('different')) {
    return 'no';
  } else {
    return 'unclear';
  }
}

// Update appointment with confirmed time
async function updateAppointmentWithTime(selectedAppointment, newDateTime, callerInfo, language, streamSid) {
  try {
    // Calculate duration
    const originalStart = new Date(selectedAppointment.start.dateTime);
    const originalEnd = new Date(selectedAppointment.end.dateTime);
    const duration = originalEnd.getTime() - originalStart.getTime();
    const newEndTime = new Date(newDateTime.getTime() + duration);
    
    // Update the appointment
    const updateData = {
      start: {
        dateTime: newDateTime.toISOString(),
        timeZone: selectedAppointment.start.timeZone || 'UTC'
      },
      end: {
        dateTime: newEndTime.toISOString(),
        timeZone: selectedAppointment.end.timeZone || 'UTC'
      }
    };
    
    try {
      await googleCalendarService.updateAppointment(selectedAppointment.id, updateData);
      
      // Log the delay to database
      await logDelayToDatabase({
        appointmentId: selectedAppointment.id,
        originalTime: selectedAppointment.start.dateTime,
        newTime: newDateTime.toISOString(),
        teammateInfo: callerInfo,
        reason: 'Teammate requested delay',
        status: 'updated'
      });
      
      // Make outbound call to customer
      const customerPhone = '+923450448426'; // Customer number to call
      const twilioPhoneNumber = '+4981424634017'; // Your Twilio phone number
      const customerMessage = `Hello! This is regarding your appointment "${selectedAppointment.summary}". We need to reschedule it to ${formatDateTime(newDateTime.toISOString())}. Is this new time okay with you?`;
      
      try {
        const callResult = await makeOutboundCallToCustomer(customerPhone, customerMessage, selectedAppointment, formatDateTime(newDateTime.toISOString()));
        
        if (callResult.success) {
          const response = `Perfect! I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI'm now calling the customer at ${customerPhone} to confirm the new time. Please wait for their response.`;
          
          const workflowData = {
            step: 'waiting_for_customer',
            selectedAppointment: selectedAppointment,
            newTime: newDateTime.toISOString(),
            customerPhone: customerPhone,
            callSid: callResult.callSid,
            callerInfo: callerInfo,
            language: language,
            streamSid: streamSid,
            shouldEndCall: false
          };
          
          return { response, workflowData };
        } else {
          // Fallback if call fails
          const response = `I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI tried to call the customer but couldn't reach them. You may want to contact them directly. Do you need any more help with delaying meetings?`;
          
          const workflowData = {
            step: 'ask_more_help',
            selectedAppointment: selectedAppointment,
            newTime: newDateTime.toISOString(),
            callerInfo: callerInfo,
            language: language,
            streamSid: streamSid,
            shouldEndCall: false
          };
          
          return { response, workflowData };
        }
      } catch (error) {
        console.error('‚ùå Failed to make outbound call:', error);
        
        // Fallback if call fails
        const response = `I've successfully delayed "${selectedAppointment.summary}" to ${formatDateTime(newDateTime.toISOString())}.\n\nI tried to call the customer but couldn't reach them. You may want to contact them directly. Do you need any more help with delaying meetings?`;
        
        const workflowData = {
          step: 'ask_more_help',
          selectedAppointment: selectedAppointment,
          newTime: newDateTime.toISOString(),
          callerInfo: callerInfo,
          language: language,
          streamSid: streamSid,
          shouldEndCall: false
        };
        
        return { response, workflowData };
      }
      
    } catch (error) {
      globalTimingLogger.logError(error, 'Update Appointment');
      return {
        response: "I'm sorry, I couldn't update the appointment in the calendar. Please try again or contact support.",
        workflowData: { shouldEndCall: true }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Update Appointment With Time');
    return {
      response: "I'm having trouble processing the appointment update. Please try again.",
      workflowData: { shouldEndCall: true }
    };
  }
}

// Handle waiting for customer response
async function handleWaitingForCustomer(transcript, sessionData, streamSid) {
  try {
    const { callerInfo, language } = sessionData;
    
    // Check if teammate wants to end the call or wait more
    const wantsToEnd = checkEndCallRequest(transcript);
    
    if (wantsToEnd === 'yes') {
      // End the call immediately
      const response = `Thank you for using the delay notification system! I'll inform the customer about the changes and send you a text message with the details. Have a great day!`;
      
      return {
        response: response,
        workflowData: { shouldEndCall: true }
      };
    } else {
      // Keep waiting
      const response = `I'm still waiting for the customer's response. You can say "no" if you want to end the call now, or wait a bit more.`;
      
      return {
        response: response,
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle Waiting For Customer');
    return {
      response: "I'm having trouble processing your response. Please try again.",
      workflowData: { ...sessionData, shouldEndCall: false }
    };
  }
}

// Check if teammate wants to end the call
function checkEndCallRequest(transcript) {
  const lowerTranscript = transcript.toLowerCase();
  
  if (lowerTranscript.includes('no') || lowerTranscript.includes('not') ||
      lowerTranscript.includes('done') || lowerTranscript.includes('finished') ||
      lowerTranscript.includes('end') || lowerTranscript.includes('stop') ||
      lowerTranscript.includes('don\'t want') || lowerTranscript.includes('don\'t need')) {
    return 'yes';
  } else {
    return 'no';
  }
}

// Handle more help request
async function handleMoreHelpRequest(transcript, sessionData, streamSid) {
  try {
    const { callerInfo, language } = sessionData;
    
    // Check if teammate wants more help
    const wantsMoreHelp = checkMoreHelpRequest(transcript);
    
    if (wantsMoreHelp === 'yes') {
      // Get fresh appointments and start over
      const appointments = await googleCalendarService.getAppointments(callerInfo);
      const appointmentsList = formatAppointmentsForTeammate(appointments);
      
      const response = `Great! I can help you delay another appointment. Here are your current appointments:\n\n${appointmentsList}\n\nWhich appointment would you like to delay?`;
      
      const workflowData = {
        step: 'select_appointment',
        appointments: appointments,
        callerInfo: callerInfo,
        language: language,
        streamSid: streamSid,
        shouldEndCall: false
      };
      
      return { response, workflowData };
      
    } else if (wantsMoreHelp === 'no') {
      // End the call immediately
      const response = `Thank you for using the delay notification system! I'll inform the customer about the changes and send you a text message with the details. Have a great day!`;
      
      return {
        response: response,
        workflowData: { shouldEndCall: true }
      };
      
    } else {
      // Unclear response
      return {
        response: "I'm not sure if you need more help or not. Could you please say 'yes' if you want to delay another appointment, or 'no' if you're done?",
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle More Help Request');
    return {
      response: "I'm having trouble understanding your response. Please try again.",
      workflowData: { ...sessionData, shouldEndCall: false }
    };
  }
}

// Check if teammate wants more help
function checkMoreHelpRequest(transcript) {
  const lowerTranscript = transcript.toLowerCase();
  
  if (lowerTranscript.includes('yes') || lowerTranscript.includes('okay') || 
      lowerTranscript.includes('ok') || lowerTranscript.includes('sure') ||
      lowerTranscript.includes('more') || lowerTranscript.includes('another') ||
      lowerTranscript.includes('help') || lowerTranscript.includes('delay')) {
    return 'yes';
  } else if (lowerTranscript.includes('no') || lowerTranscript.includes('not') ||
             lowerTranscript.includes('done') || lowerTranscript.includes('finished') ||
             lowerTranscript.includes('all set') || lowerTranscript.includes('good')) {
    return 'no';
  } else {
    return 'unclear';
  }
}

// Handle customer confirmation
async function handleCustomerConfirmation(transcript, sessionData, streamSid) {
  try {
    const { selectedAppointment, newTime, callerInfo } = sessionData;
    
    // Check if customer agrees
    const customerAgrees = checkCustomerAgreement(transcript);
    
    if (customerAgrees === 'yes') {
      // Customer agreed - log success
      await logDelayToDatabase({
        appointmentId: selectedAppointment.id,
        originalTime: selectedAppointment.start.dateTime,
        newTime: newTime,
        teammateInfo: callerInfo,
        customerAgreed: true,
        reason: 'Customer confirmed delay',
        status: 'confirmed'
      });
      
      return {
        response: "Great! The customer has confirmed the new time. I've updated the appointment and logged this information. Thank you for using the delay notification system!",
        workflowData: { shouldEndCall: true }
      };
      
    } else if (customerAgrees === 'no') {
      // Customer disagreed - log and suggest alternative
      await logDelayToDatabase({
        appointmentId: selectedAppointment.id,
        originalTime: selectedAppointment.start.dateTime,
        newTime: newTime,
        teammateInfo: callerInfo,
        customerAgreed: false,
        reason: 'Customer declined delay',
        status: 'declined'
      });
      
      return {
        response: "I understand the customer doesn't agree with the new time. I've logged this information. You may want to suggest an alternative time or keep the original appointment. Is there anything else I can help you with?",
        workflowData: { shouldEndCall: false }
      };
      
    } else {
      // Unclear response
      return {
        response: "I'm not sure if the customer agreed or not. Could you please ask them again if they're okay with the new time?",
        workflowData: { ...sessionData, shouldEndCall: false }
      };
    }
    
  } catch (error) {
    globalTimingLogger.logError(error, 'Handle Customer Confirmation');
    return {
      response: "I'm having trouble processing the customer's response. Please try again.",
      workflowData: { ...sessionData, shouldEndCall: false }
    };
  }
}

// Check if customer agrees to the new time
function checkCustomerAgreement(transcript) {
  const lowerTranscript = transcript.toLowerCase();
  
  if (lowerTranscript.includes('yes') || lowerTranscript.includes('okay') || 
      lowerTranscript.includes('ok') || lowerTranscript.includes('sure') ||
      lowerTranscript.includes('fine') || lowerTranscript.includes('good') ||
      lowerTranscript.includes('agreed') || lowerTranscript.includes('confirmed')) {
    return 'yes';
  } else if (lowerTranscript.includes('no') || lowerTranscript.includes('not') ||
             lowerTranscript.includes('disagree') || lowerTranscript.includes('decline') ||
             lowerTranscript.includes('can\'t') || lowerTranscript.includes('cannot')) {
    return 'no';
  } else {
    return 'unclear';
  }
}

// Format appointments for teammate display
function formatAppointmentsForTeammate(appointments) {
  if (!appointments || appointments.length === 0) {
    return "No appointments found.";
  }
  
  return appointments.map((apt, index) => {
    const startTime = formatDateTime(apt.start.dateTime);
    return `${index + 1}. ${apt.summary} - ${startTime}`;
  }).join('\n');
}

// Format date and time for display
function formatDateTime(dateTimeStr) {
  const date = new Date(dateTimeStr);
  return date.toLocaleString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
}

// Log delay information to database
async function logDelayToDatabase(delayData) {
  try {
    const db = await databaseConnection.getConnection();
    const collection = db.collection('delay_notifications');
    
    const logEntry = {
      ...delayData,
      timestamp: new Date().toISOString(),
      createdAt: new Date()
    };
    
    await collection.insertOne(logEntry);
    console.log('‚úÖ Delay notification logged to database');
    
  } catch (error) {
    console.error('‚ùå Failed to log delay notification:', error);
    // Don't throw error - logging failure shouldn't break the workflow
  }
}

// Make outbound call to customer
async function makeOutboundCallToCustomer(customerPhone, message, appointmentDetails, newTime) {
  try {
    console.log(`üìû Making outbound call to ${customerPhone}: ${message}`);
    
    // Use the new real outbound call session service
    const result = await outboundCallSession.makeCallToCustomer(customerPhone, appointmentDetails, newTime);
    
    return result;
    
  } catch (error) {
    console.error('‚ùå Failed to make outbound call:', error);
    return { success: false, error: error.message };
  }
}

module.exports = {
  delayNotificationWorkflow,
  continueDelayWorkflow
};
